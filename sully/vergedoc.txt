VERGE Developer's Guide
  by Hahn (hahn@ll.net)

Last revised 24.DEC.97

>< Information updated between the 02.OCT.97 and 24.DEC.97
>< releases will be indented in a manner like this.

| Hahn's family left early this morning (Dec 24) to visit relatives for
| Christmas, a wedding, and other things. He fought bravely to get as much
| of the docs done as he could, getting only 4 hours of sleep, but alas, not
| all of it was completed. As such, sections of this version of VERGEDOC.TXT
| which are intended in this fashion are written by vecna, and therefore will
| be slightly less comprehensible than their Hahnian counterparts. :)
| Additionally, all of the updates to VERGEC.TXT are done by me as well.

Welcome to the wonderful world of VERGE, the ultimate in PC RPG
construction kits! This document is intended to help potential game
developers get started. This document assumes that the reader has played
through the VERGE pack-in demo, has a general understanding of the game
concepts involved with a modern console RPG, and has a good imagination
and a strong idea of what he or she wants from a game they design.

Chapter 1: MapEd
Chapter 2: VergeC
Chapter 3: Items, Characters, and Equipment (and now, Magic)
Chapter 4: Importing your artwork into VERGE
Chapter 5: Appendix

1. MapEd is the main VERGE editing program. It is used to construct maps,
   the central module of VERGE games. Just about every aspect of your game
   can be created or modified using MapEd.

  A. Running MapEd:

    1. First and foremost, MapEd requires that you specify a .MAP file when
       running it. Simply typing MAPED will only earn you an
       error message. The proper usage is: MAPED <filename>.MAP. Do not
       forget to include the extension. Maped is a little bit nicer about
       wrong file names, but you must still specify an extension.

    2. To get a feel for MapEd, try running it with one of the existing maps.
       For example, try running MAPED VILLAGE.MAP. You should see a map of
       a village appear shortly afterward. Hit ESC to summon the main menu
       of MapEd. You can click on Exit or hit Alt-X to leave the program.
       Hitting F10, or clicking on Save from the main menu will save your
       map. As with anything in computer life, save often. Hitting M will
       summon the Map Options window. These options are better explained
       later in this document.

    3. MapEd has a Map Load function. Hit Alt-L to use it. You can type
       in a map name to load immediately instead of having to exit MapEd, and
       restart with a different map to load. Note that the Map Loader will
       NOT ask you to save unsaved changes, so be sure to save your progress
       before using it.

><  4. MapEd has a few new features:
><
><     - Hitting F12 will create a PCX image from the map's current VSP.
><
><     - Hitting F11 will create a PCX image from the map's tile layers itself
><       named MINIMAP.PCX. This is an image with the same dimensions as your
><       map, and each tile from your map will be represented by one pixel.
><       Note that the image will be created from whichever layers are
><       visible at the time, so switch between modes 1, 2, or 3 to the
><       desired view before using.
><
><     - Auto 5-minute backup. While working in MapEd, the files $BACKUP$.MAP and
><       $BACKUP$.VSP will be created periodically. If MapEd (or your machine)
><       crashes, these might save you a great deal of work. Bear in mind that
><       after confirming which map $BACKUP$.MAP is, you should probably copy it
><       over the real map immediately. Working on $BACKUP$.MAP by itself is
><       risky, as it will be overwritten the next time you edit a new map.

  NOTE: This documentation assumes that you have the common sense to include
        all of your important VERGE files in the same directory. When you get
        serious into editing, you'll find it brings much peace of mind if you
        do NOT separate files into different directories. Things like .VSP
        and .PAL files especially should be right alongside all of your maps
        and other graphic work.

  B. Layers:

    1. One of the most integral aspects of a map you must understand is the
       layers. Each map has two(2) layers of tiles, the foreground and the
       background. These layers behave differently depending on the map's
       PARALLAX MODE. Generally, the FOREGROUND grid of tiles is drawn on top
       of the BACKGROUND grid of tiles. To change a map's parallax mode or
       parallax multiplier and divisor from within MapEd, hit M to bring up
       the Map Options window.

       There is a third graphic layer, dubbed the VergeC Layer. However,
       this layer can only be edited and used through VergeC event scripts,
       so your map editing in MapEd should be unaffected by this innovation.

><     New to this release: The VergeC graphic layer is not necessarily drawn
><     above everything else, and may be drawn inbetween other map layers.
><     See the 'Gratuitious Eye Candy' section of VergeC.TXT for more details.

      a. Parallax Modes define how the tiles of the foreground and background
         layers interact with each other and with the characters during
         gameplay. A map's Parallax Mode can be modified at any time during
         map creation, editing, or even during the game's execution. Here is
         a description of the four available modes:

        Mode 0: This mode is the most commonly used in maps, and is
                recommended for beginners. It keeps the two layers of tiles
                at the same rate of scrolling, and draws the characters
                above the background, and behind the foreground. This allows
                the player to move over the floor, but also be able to walk
                behind pillars, trees, walls, and other features in the map.

        Mode 1: This mode also has the foreground and background use the same
                rate of scrolling, but the players are drawn on top of both
                the foreground and background. This is usually useful only
                when the designer wishes to make foreground tiles appear
                transparent over the background, and be drawn beneath the
                characters, saving on the number of tiles necessary to
                create the map.

        Mode 2: This mode draws the characters on top of both layers, but
                the background scrolls at a slower speed than the foreground,
                as determined by the parallax MULTIPLIER and DIVISOR. This is
                used in scenes where the characters are assumed to be on a
                highly elevated surface, with a graphic background scrolling
                deep beneath them. This mode is exceptional in that it is the
                FOREGROUND the designer uses when planning the player's main
                walking areas.

        Mode 3: This mode draws the characters on top of the background, but
                beneath the foreground, as well as causing the foreground to
                scroll faster than the background, creating the impression
                that the player is moving beneath some elevated features,
                such as clouds or ceiling pipes.



      b. The Parallax MULTIPLIER and DIVISOR determine how quickly the layers
         scroll in Mode 2 and Mode 3 Parallax maps ONLY. They have no effect
         in maps with Parallax mode 0 or 1. For a Mode 2 map, the multiplier
         divided by the divisor should be a number less than 1. Good examples
         are multiplier=1, divisor=2, and multiplier=2, divisor=3. The
         resulting quotient will determine the ratio at which the background
         scrolls compared to the foreground. For a Mode 3 map, the number
         should be greater than 1. Multiplier=2, divisor=1 and Multiplier=3,
         divisor=2 are commonly used examples.

      NOTE: Never put a value of 0 in the Divisor field. Doing so will
            prevent your map from running. For mode 0 and mode 1 maps,
            the simplest thing to do is to fill the multiplier and divisor
            fields with a value of 1.

    2. The foreground and background layers of a map are completely
       separate. In MapEd, there are three available views. Hitting 1 will
       switch to Background mode, and this is the mode that MapEd defaults
       to when first run. This mode, obviously, shows (and edits) only the
       background grid of tiles. Hitting 2 will switch to Foreground mode.
       In this mode, the foreground is the only layer viewed and edited.
       Pressing 3 switches to Both layers mode, showing both layers on top
       of each other.

       CAUTION: View mode 3 can be deceptive. Although both layers are
                visible, any changes made in this view mode are made to the
                FOREGROUND layer. Do not build your background layer while
                using view mode 3. This mode should only be used when
                seeing how well the two layers fit together, or when making
                changes to the foreground that require seeing the background.

    3. A warning about Parallax mode 2 and mode 3 maps: Remember that the
       engine will cause the layers to scroll at different speeds when the
       game is run. When you scroll within MapEd, this speed will be
       simulated, but coordinates viewed while in view mode 3 may be
       deceptive. It is recommended that you work on the two layers
       individually, using view modes 1 and 2, then switch to mode 3 to
       see how well they are integrated.

  C. Basic Editing

    1. Tiles are the heart and soul of a map. The tiles are stored in .VSP
       files. What on earth is a .VSP, you ask? It's a "V"GA "SP"rite file
       that holds a set of tiles, as well as the data that makes them
       animate. Look in the Graphics section later in this document for help
       on making your own .VSPs. For now, try to use the default tile set
       (HAHN01.VSP) to get a feel for MapEd and all of its features.

      a. Tiles are layed down on the map by using the left and right mouse
         clicks. Each click can have a separate tile assigned to it, and
         those tiles are depicted in the small boxes in the lower right
         corner of the screen in MapEd. There are many different ways to
         select a tile:

        1. A = Next tile for left click.     S = Next tile for right click.
           Z = Previous tile for left click. X = Previous tile for right click.

        2. If you need to select a tile that already has an instance in the
           map you are editing, simply position the arrow cursor over the
           desired tile, hold down the (/) slash key, then use left click to
           assign that tile to left button, or right click to assign the tile
           to right button.

        3. Hit Ctrl. This brings up the Tile Selector, showing every tile in
           the VSP. Use the up and down arrows to scroll if the number of
           tiles exceeds what can be shown on one screen. Use the left or
           right mouse buttons to assign tiles to those buttons respectively.
           Hit ESC to leave the Tile Selector without selecting a tile.

           The Tile Selector has a Padded mode available. Press P to toggle
           Padded mode. This will separate the tiles with a grid of pixels. This
           is useful for tile artists who use alternate paint programs to edit
           their tiles and make large shapes. Padded mode allows them to see the
           tiles line up in MapEd as they would in the tile set's PCX image.

      NOTE: Remind yourself to be constantly aware of which tile layer you
            are currently viewing when you lay down your tiles, and be
            especially cautious with view mode 3.

      b. After experimenting for a short time with laying down tiles, it
         quickly becomes apparent how easy it is to make a nice map. There
         are a few tricks available that can make a simple job even simpler:

        1. Block Fill: If you wish to create a rectangular area filled with
           a specific tile, first of all, assign the desired tile to the
           LEFT mouse button. Next, position the arrow cursor over a corner
           of the desired region, hold down LEFT SHIFT and the RIGHT mouse
           button, then drag the resulting shaded area to the desired size
           and release.

        2. Copy/Paste: If you have a unique arrangment of tiles that you wish
           to duplicate elsewhere, such as a house, you may hold down LEFT
           SHIFT and the LEFT mouse button, then drag the shaded area over
           the area you wish to copy. A "P" will appear in the lower left
           corner of the screen. Now, simply use the left mouse button to
           create copies of what you captured. Press "P" to forget what you
           copied.

        CAUTION: Copy/Paste can be very destructive if used irresponsibly.
                 Remember that ALL left mouse clicks will create a copy of
                 what you captured. Whenever you see a "P" in the lower left
                 corner, be warned that your left mouse clicks may have
                 undesirable effects. Again, hit "P" to remove the copied
                 tiles.

><      3. Speed Scroll: To move around a large map one screen at a time:
><         PgUp = Up; PgDn = Down; End = Right; Home = Left

    2. Obstructions

      a. Obstructions determine where the player can and cannot move during
         gameplay. The individual graphics of your tiles have no effect on
         the player's movements. A path tile is just as open as a brick wall
         tile unless you tell your map differently. Press "O" to switch
         MapEd's view to Obstruction mode, which is yet another view mode,
         just like Background, Foreground, and Both Layer modes. In this
         view mode, both the background and foreground are visible. Left
         clicking on a tile will shade it, thereby making it obstructed.
         Right clicking on a shaded tile will remove the obstruction.

    3. Zones

      a. Zones determine where events occur in your map. The Event system
         is accomplished through VergeC, VERGE's flexible, powerful, and
         easy-to-use programming language, and that is explained in Chapter
         2. This section will deal with the MapEd aspect of Zones.

        1. Hit "N" to switch to Zone view mode, which is yet another view
           mode, like Obstruction, Background, etc. You will notice both
           the background and foreground are visible in this mode. In the
           lower right corner of the screen, you can see the Zone that is
           currently assigned to the mouse button. In the upper right corner
           of the screen, you can see the Zone of the tile that the arrow
           cursor is currently positioned over.

        2. To change which zone is assigned to the mouse button, use the
           A key for next zone, and the Z key for previous zone. You can
           have 128 zones per map. Left-clicking on a tile will change it's
           zone assignment to what is currently selected (shown in the lower
           right corner). Right clicking will change the tile to Zone 0.

        3. To change the properties of a zone, first assign it to the mouse
           button using the A and Z keys, then hit Ctrl.

        NOTE: It is recommended you do not alter the properties of Zone 0.
              It is the default zone that every tile begins with, and should
              be left alone except for the savegame description.

          a. Zone: This is the name of the zone, and is for your reference
             only. The player will never see it.

          b. Event: This is a reference number to the event that will be
             run when the zone is encountered. This is best left alone for
             now and will be discussed later in Chapter 2.

          c. Chance: This is the chance that the specified event will occur
             when the player steps into the zone. The value can range from
             0 (never happens) to 255 (always happens), which means a chance
             of 50% would actually be represented by a value of 128.

          d. Delay: This is the number of steps that the player must take
             within the zone before there is even a chance the event can
             occur. After a number of steps equal to the delay have been
             taken, chance will be computed normally.

          e. Desc: This is the area description that will appear in the
             player's savegame files when the game is saved in that zone.

          f. Allow Adjacent Activation: If this box is marked with an X, then
             the player may activate the event assigned to that zone by
             facing the zone from an adjacent tile and pressing the
             "Talk/Confirm" control.

          NOTE: When a zone's event is activated through Adjacent Activation,
                it WILL occur regardless of the chance value.

          g. Edit Scripts: This will summon your text editor, with the
             current map's VergeC file loaded and ready to edit. This is
             better explained in Chapter 2.

><   4. Entities
><
><     a. Entities are animated characters that inhabit your map. They use CHR
><        files just like the characters, and they can behave in a manner of ways.
><        Activating entities can run events in your map, and you can manipulate
><        entities to put on little 'cutscenes', such as it is.
><
><     b. Press "E" in MapEd to bring up Entity Mode. Both tile layers will be
><        shown. Existing entities will be shown as black mesh boxes.
><
><     c. Pressing Ctrl will bring up the Map's CHR list. You may add CHRs here for
><        the map's entities to use. Realize that this list starts at #5, as the
><        CHRs 0-4 are what the player characters use. Press the down arrow for
><        more slots if needed.
><
><     d. Pressing "S" will bring up the Map's movement script list. Press Up arrow
><        and Down arrow to switch between scripts, and press "A" if you need to
><        allocate a new one. These are scripts which will be available to the
><        entities that have controlled movement. These controls can be used:
><
><        U=Up;D=Down;L=Left;R=Right;X=Move to X axis value;Y=Move to Y axis value;
><             Z=Specify Frame;F=Face;W=Wait;B=Loop to beginning.
><
><        Example: U4 D3 W50 Z21 W50 L3 F0 W30 B
><
><        Note that spaces between commands are not necessary.
><
><     e. Left-click on an empty tile to create a new Entity. It will automatically
><        be assigned a number. Do not be alarmed that the first one you create is
><        Entity #5, as the player characters are entities #0-4. Clicking on an
><        existing entity will bring up the entity's properties. Move the cursor over
><        an entity and hit Delete to remove the entity from your map.
><
><       1. X/Y Position: Changing these values will move your entity.
><
><       2. Activation Method: Determines how the Entity's event comes to occur.
><          "Actv" means that the player must face the entity and press the
><          Talk/Examine/Confirm control. "Adjc" means that the entity's action
><          will occur as soon as it reaches a tile adjacent to the group.
><
><       3. Act. Script: Which event from the map's VC file will be run when the
><          entity is activated.
><
><       4. Speed: The entity's moving speed.
><          Speed  Pixels/second
><          1      25
><          2      33
><          3      50
><          4      100
><          5      200
><          6      300
><          7      400
><          NOTE: The player's default walking speed is 4.
><
><       5. CHR: Which CHR from the map's CHR list is used for this entity.
><
><       6. Desc: Short phrase about the entity; for your use only.
><
><       7. Ignore Obstructions: If checked, the entity can move through obstructions,
><          the party, and other entities.
><
><       8. Face Player: If checked, the entity will face the player when activated.
><
><       9. Move Code: Control's the entity's behavior.
><          0: Stopped
><          1: Wander - steps specify how many steps are taken before Delay occurs
><          2: Like Wander, but you may confine the entity to a rectangular area.
><          3: Like Wander, but you may confine the entity to a specific zone.
><          4: Run a Movement Script from the map's movement script list.
><
><       10: Chase: If checked, the entity will attempt to pursue the players when they
><           come in range of the specified Chase Distance. When an entity begins chasing,
><           its speed changes to the value in Chase Speed.

  D. Advanced Editing

    1. Tile Animations

      a. In each VSP (tile set), you can have 100 sets of animated tiles.
         To create an animation, press Ctrl from within MapEd to bring up
         the Tile Selector, then hit "V". This will summon the Animation
         Editor.

      b. Each of the 100 Animations contains a Start tile, and End tile, and
         a Delay. The Start Tile and End Tile are, obviously, the first and
         last of the string of tiles that the animation will cycle through.
         The Delay is how much time each frame is visible before moving on
         to the next one. This is represented in 'ticks', which are 100ths of
         second, so a delay of 200 would show each tile for two seconds
         before moving on to the next one.

         Tile animations, and all timed functions in VERGE, operate in
         100ths of a second.

      c. Press A to switch to the next Animation, or Z to move to the
         previous animation. When are you done editing, hit Esc to return to
         the Tile Selector. Now, whenever you set down a copy of a tile that
         is involved in an animation, you will see it go through its cycles
         both from within MapEd and the actual game engine.

><    d. Animation Modes: There are different modes you can put the tile
><       animation in:
><       0 = Linear(normal); 1 = Reverse; 2 = Random; 3 = Loop Back and Forth

    2. VSP Alteration

      a. There are many ways to edit the VSP (tile set) you are using
         directly from within MapEd. All of these changes must be made from
         within the Tile Selector (hitting Ctrl).

        1. Tile Allocation: To increase the number of tiles in your VSP,
           simply hit A. A blank tile will be appended to the end of the
           tile set.

        2. Tile Copying: If you wish to make a copy of an existing tile,
           position the mouse cursor over the desired tile, hit C, then
           left-click on destination where you want the tile to be copied.
           If you want to make a 'transparent' copy of a tile, meaning that
           only the non-color 0 components of a tile are copied, use right
           click instead of left click. This way, you can overlap a tile on
           top of another; useful for chests, levers, etc.

        3. Tile Rotation: To flip a tile, position the mouse cursor over the
           desired tile. Hit X to flip horizontally, Y to flip vertically,
           or Z to flip 90 degrees.

        NOTE: Tile Rotation alters the tile image itself, and therefore will
              alter every existing instance of the tile on your maps. You
              cannot rotate a tile, then lay down some of the tiles, rotate
              it again and make more unique tiles. Use Tile Copying to make
              multiple copies of the tile in your VSP, then rotate each one
              as needed.

        4. Tile Deletion: Simply position the mouse cursor
           over the undesirable tile and hit D. This will remove the tile from the
           VSP, and slide all tiles after it back one. It will also reduce the
           the total number of tiles in VSP by 1.

        5. Tile Insertion: Position the mouse cursor in the
           area of the tile set you need a new tile. Hit I and a new tile will be
           created. This is effectively like pressing A to allocate an extra tile,
           but the new tile can be generated at any point in the VSP.

        6. Tile Editing: This is one of the most useful areas of MapEd. It
           allows you to edit the tile image itself. To edit a tile, position
           the mouse cursor of the desired tile and hit E.

        NOTE: The Tile Editor is only one way to create new tile images.
              Look in Chapter 4 below to see other ways to make your own
              tile sets.

          a. You will see a blown-up image of the tile in the upper left.
             You can edit the color of the pixels with the left and right
             mouse buttons, which can each be assigned a separate color by
             using the respective buttons on the palette array below. The
             colors of the left and right mouse buttons are depicted as
             horizontal strips in the upper right.

          b. Alternately, you can use the D key to scroll to the next color,
             or the C key to scroll to the previous color. Also, if you wish
             to assign the left or right mouse button to a color that already
             exists in the tile, hold down the S key, and use the respective
             mouse button on a pixel of the desired color within the tile.

          c. The Tile Rotation controls also work from within the Tile
             Editor. X = horizontal flip. Y = vertical flip.
             Z = 90 degree flip.

          d. When you are finished altering the tile, hit Esc to return to
             the tile selector.

    NOTE: All of these VSP alterations do not affect the actual VSP until
          your map is saved. If you make a nasty error, you can leave MapEd
          without saving to leave the VSP intact as it was when you started
          MapEd.

  E. Creating and Testing New Maps.

    1. By now, you know how to make a decent map of tiles. You are probably
       just itching to make your own maps from scratch and test them out
       with the actual game engine, aren't you?

      a. NEWMAP is the utility for building new maps. To run it, simply type
         NEWMAP.

        1. Enter the filename for your new map. Do NOT forget to include the
           .MAP extension.

        2. Enter which VSP (tile set) your map will use. You must select an
           exisiting VSP, and you may not change this later, so be sure you
           select the correct VSP. Again, do not forget to specify the .VSP
           extension.

        3. Enter the song you want to play in this map. Enter the name of
           a .MOD, .S3M, or .XM music module file you want to play during
           the map's execution. You must specify an extension. This can be
           changed later in MapEd from the Map Options window (M).

        4. Enter the Parallax mode for your map. These are described above
           in the Layers section. This can also be changed from within
           MapEd.

        5. Enter the Parallax Multiplier and Divisor. Do not enter a Divisor
           of 0. For a Parallax Mode 0 or 1 map, the easiest thing is to
           just enter 1 for both values. Read above in the Layers section
           for Parallax Mode 2 and 3 maps. This can also be changed later
           within MapEd.

        6. Enter the ShowMap flag. If you select a 1, then the map's name
           will be shown when the player enters the map (currently not
           implemented). You can change this later in MapEd.

        7. Enter the Save flag. If you select a 1, the player will be
           allowed the save the game when in the map. You can change this
           later in MapEd, and you can also adjust this property during
           gameplay through EnableSave and DisableSave events.

        8. Enter the starting coordinates where the player enters the map.
           This can be changed in MapEd, and MapSwitch events can also
           specify alternate starting locations other than the default
           coordinates.

        9. Enter the Camouflage flag. If you enter 1, the player will be
           able to use any available "Camouflage" skills in the map to
           briefly avoid enemy encounters. This can be changed later from
           within MapEd (currently not implemented).

        10. Enter the Warp flag. If this is a 1, the player can use any
            available "Warp" effects to escape back to where the map was
            entered. You can change this in MapEd.

        11. Enter the total dimensions of the map. The X coordinate must
            exceed 20, and the Y coordinate must exceed 12. You can use the
            utility MAPSIZE to alter the map's dimensions later on.

        12. Your new map is created and waiting to be edited! Both the
            foreground and background are entirely composed of tile #0 in
            your VSP. Type MAPED <filename>.MAP to edit your new map.

      b. Running your map

        1. Currently, VERGE starts a new game at the start position of
           TEST.MAP.

        2. If you want to start with one of your own maps, make a backup of
           the original TEST.MAP, then copy your new map over TEST.MAP.
           Start up a new game, and you should appear in your new map.

        NOTE: If you create several connected maps and wish to play them,
              you need only copy the first of them over TEST.MAP. The others
              can retain their original names, since MapSwitch events
              directly access the map's filenames.

============================================================================

Chapter 2: VergeC

1. By now, you know what you need to know to make the graphic parts of your
   maps work. VergeC is VERGE's internal scripting language, and is used to
   control the event system. Events are what give your maps life, and direct
   the flow of your game. Before reading this chapter, it is highly
   recommended that you copy your favorite text editor into your VERGE
   directory under the name SLED.COM because you are going to get mighty
   used to it, so get one you like. I prefer MS-DOS Edit. Just copy
   EDIT.COM over SLED.COM.

  A. The Event Structure

    1. Adding events to your map is not quite as easy as adding tiles, but
       it becomes natural once you get the hang of it. This will all become
       clearer later.

      a. Events are written in VergeC files, (extension .VC), which are
         simply plain text files in which you, the designer, script the
         events that you want to happen in your map. These VergeC files
         have the same name as the map to which they are associated,
         except for the extension. For example, DARKCAVE.VC holds the
         event scripts for DARKCAVE.MAP.

      b. The actual .VC text files have no effect on your map until they are
         COMPILED with the program VCC (VergeC Compiler). This basically
         pulls apart the events you scripted in the .VC file and attaches
         them to the appropriate map file, ready for the game engine to
         interpret. There are two ways to accomplish this:

        1. Whenever you save your map in MapEd, it will search for a .VC
           file with the same name as the map you are editing, then attempt
           to compile the scripts in the .VC to your map.

        2. If you wish to compile the scripts in a .VC file without running
           MapEd, you can simply type VCC <name>. The name is the title of
           both the map and VergeC file you wish to combine. You need not
           specify an extension, since both the .MAP and .VC are required.
           So, simply typing VCC DARKCAVE will compile the scripts in
           DARKCAVE.VC and attach them to DARKCAVE.MAP.

      c. About now, you are probably thinking "That sounds great, but...
         how do I script the events in my .VC files?". Glad you asked!

  B. Scripting Events

    1. There are two ways in which to open your .VC file for editing.

      a. Within MapEd, switch to Zone view mode (N), and hit Ctrl to bring
         up the Zone properties window. Hit Edit Scripts, and you will be
         whisked away to the text editor in your VERGE directory, with the
         appropriate VergeC file loaded and ready. If you are editing a new
         map, it will be, obviously, blank.

      NOTE: With Sled, the default VERGE text editor, F4 will save your file,
            and F7 will exit the text editor.

      b. If you want to edit your scripts without running MapEd, simply open
         up the appropriate .VC file with any text editor, even Windows
         Notepad, and edit it from there.

    2. A VergeC script file consists of any number of event scripts. An
       event script is defined by this structure:

       event
       {
       }

       Where everything after the first curly brace and before the second one
       is the actual event code to execute. These enclosed event scripts are
       automatically "numbered" by the engine starting at 0,1,2,etc.

    3. The AutoExec event: Event #0 (the first enclosed event script) is the
       AutoExec event for your map. This event cannot be called normally by
       a zone, because it AUTOMATICALLY runs every time your map is loaded.
       This is extremely useful in many ways, but always keep in mind it is
       there. If you do not wish to have any events called when your map is
       loaded, you MUST still include a blank event structure at top of your
       VergeC file.

    4. Commands: Commands are the heart and soul of events. Commands are a
       wide array of functions that can change the state of the game, make
       things happen, and direct the course of the game. You can script any
       number of commands in a single event. To script a single command,
       first reference VergeC.TXT and find the command you need. That will
       tell you which parameters are required in the parentheses. Suppose
       you want to script a simple Warp event. Your event script will look
       like this:

       event
       {
        warp(56,12,0);
       }

       Note that spacing does not matter in your VergeC files, but you may
       wish to use indentation and spacing to make your code more readable.

       NOTE: *All* commands must end with a semi-colon after the parentheses.

       Reading VergeC.TXT will reveal that each command has a different
       set of parameters it needs. You must include all the parameters or
       your .VC will not compile. To add multiple commands to your event
       script, simply list them sequentially. Example:

       event
       {
        soundeffect(3);
        text(0,"The teleporter is activated!","","");
        warp(56,12,0);
       }


  C. Adding your scripted events to your map

    1. First, to attach your scripted events to your map, you need to compile
       your VergeC files as described above (either by saving your map from
       within MapEd or running VCC).

      a. If you saved your map from within MapEd after writing some event
         scripts, the window should say "Saving..." then "Compiling..."
         then return to the main MapEd screen.

      b. If you ran VCC from the DOS prompt, you should see a message
         stating, "<some number> scripts successfully compiled.".

      c. If either of these methods were unsuccessful, then you have a
         COMPILATION ERROR, which means there is some error in the syntax
         of your written code. The error says something to the effect of
         ; expected , got or something similar, and then it will show a
         number. This number is the LINE NUMBER of your VergeC text file
         where the error occurred. You will need to review your code and
         check for syntax errors. This is most commonly because you forgot
         to end a command with a semicolon, or have not matched up
         parentheses or curly braces correctly. After editing your code,
         try to compile it again to see if you get another error.

    2. To actually set up the events to run, you'll need to edit a Zone's
       properties. Switch to Zone view mode (N), then press A and Z to
       select the zone you wish to lay down. In the Event field of the
       Zone properties (Ctrl), enter the number of the Event that you want
       to run when the player encounters that zone.

><     Events do not necessarily require a Zone to run. Entities may be used
><     to test events as well. Read above in the MapEd section.

    NOTE: Remember that events are numbered from 0, so the fourth event in
          your VergeC file is actually event #3, and so on. Also recall that
          event #0 is the AutoExec event and CANNOT be called in this
          manner.

    3. If Accept Adjacent Activation is off, then you'll need to add a
       value greater than 1 in the Chance field if you want the event to
       occur (a value of 255 will make the event surely happen).

    4. Now test your map and move the characters into a zone in which you
       specified an event and it should run, provided its chance is high
       enough.

    NOTE: Recall that Adjacent Activation zones can be triggered by facing
          the zone from an adjacent square and hitting the "Talk/Confirm"
          control (default button 4 on joysticks, or Enter on keyboard).
          When a zone is triggered in this manner, the event will always
          occur. The chance value is ignored. This means that Zones with
          Adjacent Activation can effectively be placed entirely in
          obstructed tiles as long as the player can reach an adjacent
          tile from which to face the zone.

  D. Variables

    1. VergeC allows the use of Variables to control events and game data.
       If you successfully got an event to run in the previous test, I'll bet
       you're wondering, "How can I get an event to run just once?".
       Variables can be used to control just that, among other things.

      a. Flags: When a new VERGE game is started the player has 8,000
         invisible "flag" variables which are simply arbitrary slots whose
         values can be assigned and tested. The flags' names are flags[0],
         flags[1], flags[2], ... flags[7999], and so on. They ALL begin the
         game with a value of 0, and they remain 0 until they are changed
         through a VergeC command. There are a few ways with which to change
         a flag's value:

         flags[13]++;  <-- This command increases the value of flags[13] by 1.
         flags[13]--;  <-- This decreases the value of flags[13] by 1.
         flags[47]=1;  <-- This sets the value to 1, no matter what it was.
         flags[47]=0;  <-- This sets the value to 0, no matter what it was.
         flags[8]+=7   <-- This increases the value by 7.
         flags[8]-=14  <-- This decreases the value by 14.

         This changes the flag's value, but what good is that, you ask? Well,
         all Variable types can be used to replace the regular parameters
         required for event commands. For example, this is a valid command:

         Warp(43,121,0);

         However, you could also state:

         Warp(43,flags[12],0);

         This would work just as well, except it would use the value of
         whatever flags[12] is at the moment instead of using a fixed value
         for the Y coordinate. You could also state:

         Warp(flags[14]+7,flags[98]-3,0);

         This would warp the player to a coordinate 7 more than the current
         value of flags[14], and 3 less than the current value of flags[98].
         As you can see, this amounts to great flexibility.

         VergeC supports mathematical grouping for operand values. That means
         this is now valid: Warp((flags[14]*7)+(a+(b/(flags[98]-7),0);

         NOTE: The most important thing to remember about flags is that each
               one has a separate value, and you should only use a flag once
               for a specific purpose, because it is permanently stored in
               the savegames. If you use a certain flag variable to control
               if the player has slain the dragon yet, do not use that same
               flag number later on to control if the player has spoken to
               the king.

      b. Temporary Variables: Flag variables are permanently stored within
         the player's savegame files, so once you give a flag its value, it
         will remain at that value until changed by another VergeC command.
         Temporary variables are not stored in the Savegame files, but can
         be used similarly to flags. There are 26 Temporary variables, named
         A, B, C,... Z. You can alter their values in the same way you alter
         flags. Here is an example:

         C=12;         <-- Assigns a value of 12 to "C".
         A+=C;         <-- Adds the value of C to A.
         GiveItem(A);  <-- Gives the item with an index equal to A.

      c. Game Data Returns: There are a few variables that are automatically
         assigned a value depending on the current state of the game. In most
         cases, they are yes/no situations. With these variables, if the
         requested situation is false, then the variable will be given a
         value of 0. If it is true, the variable will have a value of 1.
         Here are a few of the current game data return variables:

         facing(direction)  <-- This will return the value of the player's
                                current facing. D=0; U=1; R=2; L=3.
         char(PARTY.DAT index)  <-- This tests whether or not the specified
                                    character is in the current party and returns
                                    their current order position.
         item(ITEMS.DAT index)  <-- This tests whether or not the specified
                                    item is currently possessed by the party.
         numchars     <-- This returns a value equal to the current number of
                          characters in the current party.
         partyindex(index)  <-- This will return the *PARTY.DAT* index value
                                of the character of the specified *WALKING
                                ORDER* value. For example, if Crystal is
                                character #4 in PARTY.DAT, and is currently
                                the second character in the walking order,
                                running partyindex(2) will return a 4.

         VERGE has a vast array of game data variables that can
         be used to return values in your VC code, as well as many that can be
         written to as well. Too many to list here, in fact. Refer to
         VergeC.TXT for a complete listing of what is available.

  E. Testing variables

    1. Now you know how to assign numeric values to your 8000 flag variables,
       your 26 temporary variables, and how to discover the values of your
       game data return variables. Described below is how to use those values
       to control the event execution of your scripts.

      a. IFs: IF structures are the most commonly used way to test variables.
         IFs actually take the form of "mini-events" within your event
         scripts. They are enclosed within curly braces inside your enclosed
         events. Example:

         Event
         {
          command;
          command;
          if(<conditions>)
          {
           conditional command;
           conditional command;
          }
          command;
          command;
         }

         When this event is run, the first two commands will be executed
         unconditionally. However, when the game encounters the IF structure,
         it will test the conditions stated inside the parentheses after the
         IF. If those conditions are met, the event execution will proceed
         to run all of the commands *inside* the IF bracket. Otherwise, it
         will just skip over the IF bracket and contine with the last two
         commands shown above. What do you put in the parentheses to test
         conditions, then? Examples:

         if(flags[43]=12) <-- Will run if flags[43]'s value is equal to 12.
         if(flags[43])    <-- Will run if flags[43]'s value is ANYTHING but 0.
         if(!flags[43])   <-- Will run ONLY if flags[43]'s value is 0.
         if(flags[39]>6)  <-- Will run if flags[39]'s value is greater than 6.
         if(flags[39]<8)  <-- Will run if flags[39]'s value is less than 8.
         if(flags[7]>=19) <-- Runs if the value is greater than or equal to 19.
         if(flags[7]<=52) <-- Runs if the value is less than or equal to 52.
         if(X != 57)      <-- Will run if the value of X is not equal to 57.
         if(X = flags[13])<-- Runs if the value of X and flags[13] are the same.
         if(facing(2))    <-- Runs if the party is currently facing right.
         if(!facing(0))   <-- Runs if the party is NOT facing down.
         if(char(7))      <-- Runs if character #7 is in the current party.
         if(!char(7))     <-- Runs if character #7 is NOT in the party.
         if(item(22))     <-- Runs if item #22 is owned the party.
         if(numchars(0)=2)<-- Runs if there are exactly two people in the party.
         if(numchars(0)>3)<-- Runs if more than 3 characters are in the party.
         if(partyindex(1)=4)<-- Runs if character #4 is currently in the lead.

         Note that these conditions can be combined with the word AND. Examples:

         if(!flags[7] AND char(3)) <-- Runs if flags[7]=0, and character 3 is
                                       in the current party.
         if(facing(3) AND !item(78) AND J>=4) <-- Runs if the party is facing
                                                  left, does NOT have item #78,
                                                  and the value of J is greater
                                                  than or equal to 4.

         IF structures can also be nested into each other. Example:

         if(char(3))
         {
          text(3,"You're almost as annoying as Darin.","","");
          if(char(1))
          {
           text(1,"Hey, I resent that!","","");
           if(char(5))
           {
            text(5,"Yeah, but he does have a point!","","");
           }
          }
          text(3,"Anyway, could you help us?","","");
         }

         If character #3 is not in the group, then none of this will happen.
         If he is the only character in the group, then the first and last
         lines will be printed. If 3 and 1 are in the group, but not 5, then
         the first, second, and last will be printed. If all three are in
         group, then all of this will happen. However, if only 3 and 5 are
         in the group, only the first and last commands will happen since
         the event that is conditional on character #5 is embedded in an
         IF bracket conditional on character #1.

         So, how does all of this let you make an event only happen once?
         It's quite simple. Suppose you want this text statement to only
         happen once:

         Text(0,"I'm never speaking to you again!","","");

         Simply decide on a flag variable to control this, and REMEMBER
         which flag you used. So...

         if(!flags[1])
         {
          text(0,"I'm never speaking to you again!","","");
          flags[1]++;
         }

         The first time this event is encountered, flags[1] will probably
         be 0, so the event will occur. After the text command, flags[1] will
         be incremented by 1, giving it a total value of 1. The next time
         this event is triggered, it will FAIL the IF condition since this
         event will only happen if flags[1] is 0, so nothing will happen at
         all. You may also use the same flag in a separate event, so suppose
         you have this elsewhere:

         if(flags[1])
         {
          text(0,"Oh! I see you spoke with that",
                 "ill-tempered girl!","");
         }
         if(!flags[1])
         {
          text(0,"There's a moody girl over there.",
                 "Why not go talk to her?","");
         }

  F. Advanced Scripting

    1. Comments: Comments are not required in your VergeC code, but smart
       event coders will use them to help organize and make their event
       scripts readable for future reference. They are ignored by the
       compiler. There are two ways to use comments:

      a. If you type a double slash (//) in your code, everything on that
         line after the slashes will be ignored.

         Event  // #75: When Dexter joins
         {
          Addcharacter(3);
         }

      b. The second method is to use /* and */. When the compiler encounters
         a /*, everything will be ignored until it sees a */. Example:

         Event
         {
         /* This is the part where Dexter joins after
            being seen on the path of Jujube mountains.
            The event below is number 75. */
          addcharacter(3);
         }

         The // is preferred for simple phrases that you wish commented, while
         the /* */ method is best for large areas of text to be left commented.

         NOTE: Try using commenting if you have a problematic area of your
               event script that refuses to compile. Use // before the lines
               that create errors and try recompiling until you can isolate
               the problem.

    2. Loops: Loops are devices you can use in your event scripts to perform
       an enclosed series of commands repeatedly, or to cycle through several
       variables with a single stroke. In syntax, they appear similarly to
       IF structures. To make a loop, you need to use FOR. Usage:

       FOR(<variable>,<start>,<end>,<increment>)
       {
        looped command;
        looped command;
        looped command;
       }

       When the event execution encounters a loop, it will do the following
       steps:

         a. The variable inside the FOR parentheses will be assigned a value
            equal to the "start" value in the parentheses.

         b. All of the bracketed commands inside the FOR structure will be
            executed sequentially.

         c. The variable will increase by a value equal to the INCREMENT
            in the FOR parentheses.

         d. If the value of the variable is greater than the value of the
            END parameter in the parentheses, then the loop will finish, and
            the event execution will jump down past the loop, and proceed to
            any commands beneath the final curly brace.

         e. If the value of the variable is still lower than the END value,
            then all of the bracketed commands will be run AGAIN, jumping
            back up to step b.

       This may sound too abstract to be useful, but here's an example.
       Suppose you wish to make a long wall of tiles suddenly come down in
       a straight line. Normally, that would take many separate AlterBTile
       or AlterFTile commands:

       AlterBTile(23,141,32,1);
       AlterBTile(24,141,32,1);
       AlterBTile(25,141,32,1);
       ...
       AlterBTile(37,141,32,1);

       Now, that is perfectly acceptable and will do the job, but it's a
       pain to type and makes the compiled code, and thusly the final map
       file, much larger. Here's how the same could be accomplished in a
       loop:

       For(A,23,37,1)
       {
        AlterBTile(A,141,32,1);
       }

       When the event execution encounters this, it will first assign A
       a value of 23, then run the event inside the brackets. Since A
       is 23, it will actually run AlterBTile(23,141,32,1). When it's done
       with that, A will increase by a value of the increment; in this case,
       1. So, it will become 24. Since 24 is still lower than the end
       value, 37, the loop will run again. This time, since A's value is now
       24, it will run AlterBTile(24,141,32,1). Then it's still less than
       37, so it will increase to 25 and run again, etc. When the value of
       A finally reaches 38, the loop will stop and the event execution will
       jump down beneath the FOR curly braces and proceed.

       Similarly, you can use all of the powerful, flexible variable
       operations described above in FOR loops as well. The above wall
       example could also be accomplished by:

       For(A,1,15,1)
       {
        AlterBTile(22+A,141,32,1);
       }

       VERGE supports WHILE loops.
       It works much the same as a FOR loop, but can use nearly any condition
       to control how long it executes. The syntax is such:

       While(<condition>)
       {
        commands;
       }

       The condition inside the parentheses after WHILE can be anything you can
       stuff in an IF statement. When the engine encounters a WHILE loop, it will
       repeatedly execute the commands inside the curly braces until the condition
       inside the parentheses is NOT true. Therefore, your WHILE loop should
       contain some commands that affect that condition, or else your loop will
       run endlessly.

    3. ChainEvent/Call Event and VAR functions: This is another method that
       can be used to compact, organize, and make your code generally more
       tidy, small, and efficient.

      a. ChainEvent and CallEvent are normal VergeC commands that are called
         just as any other command, except with a slight twist. The first
         value in the parentheses after a ChainEvent or CallEvent specifies
         which event to jump to. You need not include any other values in
         the parentheses, although you CAN if you wish to pass the destination
         event some values.

      NOTE: ChainEvent and CallEvent are composed identically in your VergeC
            scripts. The only difference is that ChainEvent passes all event
            execution control to the destination event, and terminates there.
            CallEvent will run the specified destination event, then return
            control to the line below the original CallEvent command.

      b. Suppose your VergeC file's event #28 look like this:

         SoundEffect(16);
         Text(0,"The portal flashes!","","");
         Warp(13,47,0);

         That works fine. You can make a separate event run this event simply
         by making commands:

         ChainEvent(28); OR
         CallEvent(28);

         That works fine as well. However, let's assume that your map contains
         several such teleporters with different destinations. You could make
         separate events for each teleporter, but your VergeC would contain
         several redundant SoundEffect and Text commands when the only real
         difference is the warp coordinates. Here is where the VAR function
         comes into play. There are 10 VAR variables, and they are named
         VAR(0),VAR(1),VAR(2)...VAR(9). They all have a value of 0, and
         are NOT remembered by the savegames, similarly to Temporary variables.

         Suppose you decide to make a "Master Teleporter Event". Replace all
         values from the parentheses that will vary depending on the
         individual instances of the event:

         SoundEffect(16);
         Text(0,"The portal flashes!","","");
         Warp(VAR(0),VAR(1),0);

         Now, if you called this event directly from a zone, the player would
         be teleported to the coordinates 0,0. This is where the optional
         additional values in a ChainEvent/CallEvent parentheses become
         useful. When you call an event with ChainEvent or CallEvent, and
         include extra values after the parameter for which event to call,
         VergeC will fill any VAR variables in the destination event
         sequentially, using those extra values. Example:

         ChainEvent(28,13,47);

         This will make the event execution jump to event #28. Since this
         particular call has an extra 13 and 47 in its parentheses, they
         will automatically go to fill the values of VAR(0) and VAR(1)
         respectively in the destination event. Therefore, you need only
         make one master event script, leave the changeable parameters
         as VAR variables, and fill them in with the specific ChainEvent
         and CallEvent commands. Here is another example, one that is
         commonly used for treasure chests:

         if(!flags[var(0)])
         {
          SoundEffect(3);
          AlterBTile(var(1),var(2),312,2);
          GiveItem(var(3));
          flags[var(0)]=1;
         }

         This would be in a Master Chest Script, not called directly by any
         zone. The actual chests zones would call events that consist of a
         single ChainEvent with the necessary parameters. Example:

         ChainEvent(47,32,56,12,5);

         When this chain is executed, event control would jump to event
         47 (the above master chest script). It would then only occur if
         flags[32] has a value of 0. If the event does occur, then it
         would play sound effect #3, then it would alter the background tile
         56,12 to have an image of 312, and not change the obstruction.
         Then, the player would be given Item #5, then flags[32] would be
         set to a value of 1, so that when the zone is next encountered,
         the IF bracketed commands do not occur.

         In short, ChainEvent, CallEvent, and VAR variables are not required
         to do anything in VergeC, but they can be immensely powerful and
         make things a lot easier if your map has several repetitive, yet
         slightly different events.

><    4. SWITCH/CASE: Cases are yet another method of simplifying and
><       empowering your VC code's flexibility. They are most useful in
><       situations where you wish to provide multiple results based on the
><       condition of some variable. Here's how they're used:
><
><       Switch(<variable to be tested>)
><       {
><         Case <result 1>: <command>;
><         Case <result 2>: <command>;
><         Case <result 3>: <command>;
><       }
><
><       When the interpreter encounters this construct, it will test the value
><       of what is given in the Switch parentheses, then run the Case statement
><       that matches it, if any. Example:
><
><       Switch(PartyIndex(1))
><       {
><         Case(1):Text(1,"My name's Darin and I'm leading this party!","","");
><         Case(2):Text(2,"I'm Sara and I'm here to pump you up!","","");
><         Case(3):Text(3,"Dexter is leading this party.","","");
><       }

><    5. GOTOs: GOTOs allow the VC execution of an event to jump directly to a
><       specified point in your current VC file. Simply put a comment such as
><       "Here:" in your VergeC code at any point. To make the event control pass
><       there in another event, simply enter "Goto Here;" Example:
><
><       Text(6,"You shall all die!","","");
><       Carrot:
><       x = Flags[15]+1;
><       if(x < 20)
><       {
><        Goto Carrot;
><       }

|     6. The VCC Preprocessor: Thanks to Zeromus, VCC now has a C-like
|        preprocessor featuring #include and #define functions. They are a tad
|        different from thier true C equivalents however:
|
|        1. #include
|           The syntax for VCC #include is simple #include filename.ext.
|           So you might put a #include chardefs.h at the top of all you MAP VCs
|           but if you use #include <chardefs.h> or #include "chardefs.h" VCC
|           will choke. VCC can recursively use these, and they can be present
|           at any point in the source file, but try to keep them all at the
|           top of the source file for speed reasons.
|
|        2. #define
|           Include's wouldn't be too useful without #defines, and they are
|           present in VergeC, albeit more noticably different than C's version
|           of them. There are two types of #defines, constants and macros.
|
|           a. Constants
|              These are real simple-like. You could say:
|              #define Cecil @4@
|
|              and then later on call:
|              text(Cecil,"Hi! I'm Cecil!","","");
|
|              You can put anything in between the two @'s you like and it will
|              be dropped in the VC in place of your constant name; you can even
|              span lines with #defines. #defines are case-sensitive.
|           b. Macros
|              These are a bit more complex, but a bit more useful as well.
|              To do a macro, you enclose the parameters in parenthesis
|              immediately after the symbol declaration, like a function
|              prototype.
|
|              #define MacroSample1(param1,dateparam)
|              @"the date is dateparam, and the param is param1"@
|
|              To call it you would type
|              text(5,MacroSample1(Hi,jan. 28),"","");
|
|            If you encounter any bugs or problems with the preprocessor
|            functions, be sure to let Zeromus know, not me, at
|            zeromus@flash.net. :)

===========================================================================

Chapter 3: Items, Characters, and Equipment

1. This chapter explains how to custom-build your own playable characters,
   items, and equipment for your VERGE game. This section assumes that you
   have the artwork you need for your current task. To learn how to create
   or import your own graphics for characters, items, etc., drop down to
   Chapter 4.

  A. Characters

    1. The playable characters are the heart and soul of any VERGE game.
       Each VERGE game can have a total cast of up to 30 playable characters
       and no more than 5 of these playable characters can be in the active
       adventuring group at one time. The complete cast is listed in
       PARTY.DAT. The top numeric value in PARTY.DAT must equal the total
       number of characters listed. As you can see, each character consists
       of three areas. All three of these must be included on a line for your
       character to work.

      a. The CHR file: The .CHR extension files are the files that contain
         the graphic walking animations for your character while they are
         exploring your maps.

      b. The CR2 file: The .CR2 extension files are the files that contain
         the portrait image of the character that is shown whenever the
         player enters that character's item, equip, or status sub-menus
         during the game.

      c. The DAT file: The character .DAT files contain the data for the
         character's official name, and their statistical attributes.

        1. The top line shows the character's name during gameplay. It must
           not exceed 8 characters in length.

        2. The second line is just a comment line to show which stats the
           lower numbers reference. Do not alter this line.

        3. The third line shows the INITIAL condition of the character at
           experience level 1. The XP value MUST be 0. The other stats should
           be the starting value for all the character's attributes.
           MaxHP must be 1 or higher, obviously.

        4. For the fourth and lower lines: All of the lines after the third
           are data controlling how much the character improves at each
           level-up. The XP value is the TOTAL number of experience points
           the character needs to achieve that level. Each of the other
           stats should have a pair of numbers, spaced apart by one space.
           These two values are the MINIMUM and MAXIMUM that the attribute
           in question will improve when that experience level is achieved.
           The second value should, obviously, be equal to or greater than
           the first value. You may write as many of these lines as you
           wish, up to what would be experience level 99.

    2. List all of the corresponding character files on each line of
       PARTY.DAT. Remember the order you have them in. The engine
       automatically indexes them as 1,2,3,etc. and that index value is
       very important to most VergeC events involving characters.

    3. To see an occurence of your character in your VERGE game, make an
       event available that has the command AddCharacter(<party.dat index>);
       and the corresponding character will join the active adventuring
       party, provided that there are less than 5 current members. To make
       a character leave the party, use the VergeC command
       RemoveCharacter(<party.dat index>);

    NOTE: Each new VERGE game begins with character index #1. If you wish
          to have more than just him/her in the starting party, put some
          AddCharacter commands in the AutoExec of TEST.VC and compile them
          into TEST.MAP.

  B. Items

    1. The list of items that are available to your VERGE game are listed
       in ITEMS.DAT. As with PARTY.DAT, the number on the top line should be
       equal to the total number of items listed in the file.

    2. Each line has several bits of data that must be included for each item.

      a. Item name: The name of your item. Must not exceed 20 characters.
      b. Item image: This is a reference number to the graphic icons in
         ITEMICON.DAT. It determines the icon that represents this item.
      c. Item description: A short phrase that describes your item when it
         is highlighted in the item menu or in a shop. Must not exceed
         20 characters.

      NOTE: If your item name or description includes spaces, you MUST use
            underscores (_), not spaces.

      d. Use type: This is a value that determines if the item can be
         activated through a Use command by the player in the Item menu.
         The different values that can go in here and described at the
         bottom of ITEMS.DAT.
      e. Use Effect: This is a reference to the various item/spell effects
         in EFFECTS.VCS that determines the effect your item has when it
         is USEd from the item menu.
      f. Item Scope: This value determines if the item effects the user,
         one selected party member, or the entire party. The description of
         these values can be found at the bottom of ITEMS.DAT.
      g. Equip type: This value determines if the item is equippable and,
         if so, which body part the item is intended for. 0 means the item
         is NOT a piece of equipment. 1=weapon,2=shield,3=body,4=head,
         5=accessory type 1, 6=accessory type 2.

      NOTE: The "Equip Type" value in ITEMS.DAT merely determines whether the
            item is a piece of equipment at all. Which characters can actually
            use the equipment is determined in EQUIP.DAT, not ITEMS.DAT.

      h. Equip index: This is a reference to an EQUIP PROFILE in EQUIP.DAT,
         which determines what effects the item has when equipped.

      i. Monetary Value: This is the money value of the item. This is how
         much the item will cost in stores. When a player sells this item,
         they will receive one-half this amount.

    3. To see an occurence of your items in your game, simply make events to
       encounter that have GiveItem commands, and be sure to reference the
       correct ITEMS.DAT index when you write these commands.

    4. Effects: The "Effect" value of the item references an effect in
       EFFECTS.VCS. EFFECTS.VCS is a compiled VergeC tile that lists the
       data for all of the game's item and spell effects. The source file
       is EFFECT.VC and to compile that VergeC file into a usable
       EFFECTS.VCS, simply type VCC EFFECTS.

      a. The EFFECT.VC file is arranged quite similarly to a map's VergeC
         event file, but rather than strucutres like:

         event
         {
         }

         The correct format for effect scripts is:

         effect
         {
         }

         The code you can put into the Effect area nearly identical to the
         VergeC you use for events. It is not recommended that you attempt
         to use any unusual commands like MapSwitch for item effects.
         Things like sound effects and banners should work fine, however.


  C. Equipment

    1. Equipment is a sub-set of items. Any item that has a non-0 value for
       its EQUIP TYPE should also reference a specific EQUIP PROFILE in
       EQUIP.DAT. This means that one or more characters can EQUIP the item
       from the Equip menu, and take on its effects, such as increases to
       Attack and Defense Power.

      a. EQUIP.DAT houses the information on what effects equippable items
         have, and which characters can equip which items. It is structured
         somewhat similarly to VergeC files, in that there are a list of
         enclosed structures that list the properties of the equipment.
         The top number in EQUIP.DAT should equal the total number of
         EQUIP PROFILES in the file.

      b. The various EQUIP PROFILES are divided by a single dash (-).
         As with VergeC files, you may use commenting here to make notes
         that will not interfere with the data processing. What do you
         put inside each equip profile, you ask?

      c. Equipment can currently modify any of the following stats: Attack
         Power, Defense Power, Hit%, Dodge%, Magic Power, Magic Resistance,
         Reaction, Ferocity, and Mobility, either positively or negatively.
         To make the equipment modify any stat, simply make a line that
         states the three-letter code for the stat, a + or - sign, and
         the value to which the stat is altered. The abbreviations are
         as follows:

         ATK - Attack Power
         DEF - Defense Power
         HIT - Hit Rate
         DOD - Dodge Rate
         MAG - Magic Power
         MGR - Magic Resistance
         REA - Reaction
         FER - Ferocity
         MBL - Mobility


         A piece of equipment may modify multiple statistics, so this is
         perfectly valid:

         ATK +54
         HIT -20
         REA +5
         FER +5
         MBL -2

      d. To determine which characters can equip the item, you will need to
         make a line with the EQABLE command. After the EQABLE, list the
         PARTY.DAT INDICES of the characters who can use that item, each
         spaced apart by one. Example:

         EQABLE 3

         This item can ONLY be equipped by character #3.

         EQABLE 1 2 3 4 7 12 18

         This item can be equipped by ANY of the above characters.

|      e. ONEQUIP/DEEQUIP. These allow you to specify a script number in
|         EFFECTS.VC which will be called when the current piece of equipment
|         is equipped or dequipped. This would allow you to create a variety
|         of equipment such as Speed Shoes, or an item that gave you 50 more
|         hp or tought you a spell while you had it equipped. Unfortunately,
|         there are currently some holes in this meaning that a ForceEquipped
|         item probably won't get called, or a DestroyItemed de-equip, nor does
|         selling it in a shop properly call DeEquip or dropping the item. All
|         of those holes will be patched soon tho, as I'll probably release
|         a patch of this version of VERGE in about a week or so.

      f. An example EQUIP.DAT may look like this:

         3
         - //Club
         ATK +5
         HIT -3
         MBL -1
         EQABLE 1 3 5
         - //Hatchet
         ATK +12
         REA -4
         EQABLE 5
         - //Cape
         DEF +5
         DOD +3
         MGR +3
         EQABLE 2 4

  D. Magic

    Magic works very much like the item system. Information about magic goes
  into the files MAGIC.DAT (similar to ITEMS.DAT), MAGICON.DAT (The icons for
  magic spells), and MAGICEQ.DAT (which contains information about who can use
  each spell). The code for each spell defines how it will function, and works
  exactly the same as all other effects scripts. Instead of being put in
  EFFECTS.VC, however, it is put in MAGIC.VC and compiled to MAGIC.VCS.
    In MAGIC.DAT, the main difference between items and magic is that magic
  has an added variable: mp cost. This is simply the casting cost, and is
  checked automatically. The equipidx refers to MAGICEQ.DAT, and every spell
  must have on, or at least reference one. Also, the equipable flag of every
  spell must be set to 1. Look at the pack-in MAGIC.DAT for examples.
    MAGICEQ.DAT only has one datum per spell, unlike EQUIP.DAT. This is
  EQABLE, which says who has the ability to use each spell.

  NOTE: THIS ONLY INFLUENCES THE PURCHASING OF SPELLS, NOT THE ACTUAL USE.

    The inclusion of magic requires that a line be added to the dat files of
  each character: spell. It is a single number for every level, saying what
  spell that character learns when they reach the level.
    MAGICON.DAT is identical in format to ITEMICON.DAT, so use pcx2item to
  create the dat file.

============================================================================

Chapter 4: Importing your artwork into VERGE

1. Virtually everything you see and hear in a VERGE game can be changed
   or customized. There are many different areas of graphics that can be
   altered, from fonts, to characters, to tiles, even the save/load
   menu. This chapter explains how to give your VERGE game that unique,
   distinctive feel that sets it apart from every other game out there.
   It is also highly recommended that any VERGE game worth the bytes it
   takes up have original character graphics and preferably some new
   and colorful tiles, although there are currently many great tiles
   sets drawn by VERGE users that could undoubtedly beautify your game.

   NOTE: Most of this chapter assumes that you have an art program capable
         of reading and saving .PCX image files. I highly recommend Deluxe
         Paint ][ Enhanced. Things like PicTor and Paint Shop Pro work as
         well. Do NOT use MSPaint. It cannot save as a .PCX file, and tends
         to scramble the palette horribly. Most importantly, all graphic
         work you do MUST use the default VERGE.PAL included with VERGE.
         Failing to do so will create quite undesirable results.

   NOTE TO PSP USERS: Paint Shop Pro can work just fine with most VERGE
                      graphics. However, it has its own unique palette
                      format, and the VERGE.PAL included with VERGE will not
                      work when making your own images. To ensure that you
                      are doing your artwork correctly, you'll need to make
                      a palette for PSP to use. First, load up ITEMS.PCX
                      from the main VERGE directory, or any other image for
                      that matter, except for KADAN.PCX or VERGE320.PCX.
                      Then, under the Colors menu, hit Save Palette, and make
                      a PSP Palette file anywhere on your hard drive. Then,
                      whenever you want to make some graphics for VERGE using
                      PSP, hit Load Palette under the Color menu. That will
                      make certain that your image is using the correct
                      palette.

  A. Tiles

  NOTE: HAHNTILE.PCX or HAHN01.PCX are examples of how to do tile set images.

    1. In Chapter 1, you learned how to draw and modify tiles in a VSP
       from within MapEd. You can do all of your tile artwork exclusively
       in MapEd, but some artists may want to do their tile artwork in a
       separate art program. Here's how to go about creating a VSP tile
       set from scratch:

      a. Your PCX image file should be 320x<any height>. Draw your tiles
         as 16x16 blocks in rows across and down, and be sure to draw a row
         of tiles across all the way to the end before you go down to the
         next row. All of your tiles should have a 1-pixel padding around
         them, and a 1-pixel border around the entire image.

      b. Once you are finished editing your image, you will need the
         utility PCX2VSP. The correct usage for this utility is:
         PCX2VSP <pcx image> <vsp output> <# of tiles to convert>.
         If you use this correctly, then you should have a brand new
         .VSP tile set ready to use in your new maps. You can always add
         more tiles to your PCX image and re-convert, and any maps that
         use the .VSP should remain unchanged, unless you tampered with
         tiles that you'd already laid down in the map.

      NOTE: There is an alternate version of PCX2VSP named PCX2VSPA. It
            creates VSP tile sets simiarly to PCX2VSP, but it does NOT
            expect a 1-pixel border around each tile. It is useful if you
            have a large image you wish to make a tile set out of, or
            if you have a screenshot of a game you want to import as a
            VERGE map. This utility is available at the main VERGE page.
            http://www.inlink.com/~vecna/crs.html.

      NOTE: Whenever you save your map in MapEd, a PCX image of your VSP
            will automatically be written to your VERGE directory with
            the same name as your .VSP. Therefore, you could draw a tile
            set with a PCX program, convert it into a .VSP tile set,
            edit the tile set further from within MapEd, then save your
            map and leave and the modifications you made in MapEd would be
            carried to your original PCX image.

  B. Characters

    1. CHR files hold the images of your character's walking figure in the
       main map engine. CR2 files hold the images of your character's
       portrait in the item, equip, and status sub-menus. You can create
       these images from scratch, and here's how:

      a. CHR images

      NOTE: DARIN.PCX is an example image template for building CHR files.

><    NOTE: CHR files now use two additional rows of frames, to form a
><          5x6 block of frames. The new frames, numbered 20 to 29, are
><          for miscellaneous use and are not required.

        1. Draw a 320x200 PCX image. Make a matrix of rectangles of palette
           color #0, six columns down and five rows across, making thirty
           boxes total. The top row is the character's images when walking
           down. The second row is the character's images when walking up.
           The third row is shown when the character is walking right, and
           the fourth row is shown when the character is walking left. During
           the game, the execution of these frames goes:
           1,2,3,2,1,4,5,4,1... etc. Each box should have a 1-pixel padding
           around it, and there should be a 1-pixel border around the
           entire image, similar to the tile set images.

        2. When you have finished editing your image, you will need the
           utility PCX2CHR. The proper usage is:
           PCX2CHR <pcx image> <chr output>. If it works correctly, then
           you should have a brand new .CHR image ready to run. To make use
           of this .CHR file, reference it in PARTY.DAT.

      b. CR2 images

      NOTE: SARA2.PCX is an example image template for building CR2 files.

        1. Draw a 320x200 PCX image. The actual portrait should be a 96x96
           square, whose upper left corner is 1 pixel right and 1 pixel down
           from the upper left corner of the whole image. Draw the desired
           character image inside the 96x96 square.

        2. Once you've drawn a portrait, you'll need the utility PCX2CHR2.
           Usage: PCX2CHR2 <pcx image> <cr2 output>. If successful, you should
           have a .CR2 file ready to use. To put it in action, add it to
           PARTY.DAT.

  C. Items

  NOTE: ITEMS.PCX is an exmaple of how to do an item set image.

    1. The item images are stored in ITEMICON.DAT. To create a new set of
       item images, you'll need to create a PCX image of 320x<any height>
       with an IDENTICAL layout to the VSP tilesets: 16x16 blocks with a
       pixel padding all around. Draw the item images inside the 16x16
       blocks.

    2. Once you've finished editing your image, you'll need to use the
       utility PCX2ITEM. The usage is:
       PCX2ITEM <pcx file> ITEMICON.DAT <#ofItems>
       This will make a ready-to-use set of item icons for you to use.
       To put the images to use, reference them in ITEMS.DAT.

  D. Fonts

    1. There are two types of fonts in the game. One is the large font
       used in dialogue boxes, and the other is a smaller font used in
       sub-menus.

      a. The Large Font

      NOTE: FONT2.PCX is an example of how a large font image should look.

        1. The PCX image should be 320x200. Each character should be
           contained within a 9x16 rectangle. As with most graphics to
           be imported into VERGE, use a 1-pixel padding around each box.
           The large font is never colorized, so you may shade freely.

        2. Once you've drawn your image, use the utility PCX2FNT.
           Usage: PCX2FNT <pcx image> MAIN.FNT.
           To test the new font, run a game and do something that brings
           up the main dialogue window.

      b. The Small Font

      NOTE: FONT4.PCX is an example of how a small font image should look.

        1. Again, the PCX image should be 320x200. However, the character
           size this time should be 7x9. Draw the boxes with a pixel
           padding, like most other images.

        NOTE: The small font is often colorized in the game during things
              like equipment and battle damage. It is highly recommended that
              the stock of your small font is composed with a SINGLE COLOR.
              Currently, the engine will alter COLOR 31 in the VERGE palette
              to the alternate colors. This will most likely be alterable
              in the future, but your small font should still be mostly made
              up one uniform color, barring outlines.

        2. When finished, use the utility PCX2FNT2. Usage:
           PCX2FNT2 <pcx image> SMALL.FNT. To test the new font, start up
           VERGE and observe the initial New/Load/Quit window.

  E. Speech Portraits

  NOTE: SPEECH.PCX is an example of how to do the speech portrait image.

    1. The file SPEECH.SPC stores the images for the speech portraits that
       can appear during Text and Prompt events. The file should be composed
       similarly to tile sets, but with larger blocks of 32x32. Draw the
       face images inside the boxes, again with a 1-pixel padding. Leave
       the first box BLANK as that is what will appear when a 0 is given
       for the portrait parameter of a Text or Prompt command.

    2. When you are finished, run the utility aptly named SPEECH.
       Usage: SPEECH <pcx image> SPEECH.SPC <#ofPortraits>. To test out
       your new portraits, make some Text commands that reference specific
       portraits in your set of speech pictures.

  F. The Text Box

  NOTE: TEXTBOX1.PCX is an example image for drawing a text box.

    1. Draw this image, again, as 320x200. The actual box image should be
       320x76. Draw it at the top of your PCX image.

    2. When completed, you need the utility PCX2BOX.
       Usage: PCX2BOX <pcx image> BOX.RAW.
       To test it, run the game and do something that triggers the main
       dialogue window.

  G. Miscellaneous Icons

  NOTE: MISC.PCX is an example of how to draw the miscellaneous icons.

    1. The format for this file will undoubtedly change quite a bit over
       the course of VERGE's development. For now, simply attempt to modify
       the existing icons where they are in the original image.

    2. To make them usable, use the utility MISC.
       Usage: MISC <pcx image> MISCICON.DAT.
       You can observe the changes as a modified cursor arrow, and bracket
       around items in the item and equip menus.

=============================================================================

Chapter 5: Appendix

1. This chapter will attempt to sum up some general questions that you might
   run across when developing your VERGE game, or to help with little bits
   of information here and there that don't quite fit into any other section.

  A. My map has outgrown its dimensions! OR
     I didn't use all my map. Can I tidy it up to make it smaller?

    1. There is a utility named MAPSIZE that can modify the dimensions of
       an existing map.

    CAUTION: MAPSIZE works just fine most of the time, but it can become
             tricky when dealing with Parallax mode 2 and 3 maps. A general
             rule is to ALWAYS make a backup of your map before running
             MAPSIZE.

    2. Simply run MAPSIZE from the DOS prompt and enter the map name and
       dimensions you want. Remember to include the .MAP extension for the
       map file you wish to resize. Obviously, if you make reduce a map's
       dimensions too much, tiles may be clipped from the edges.

  B. The introductory music and/or screens repulse me greatly! OR
     I'd like to make my own little intoduction when VERGE is run.

><  VERGE no longer uses STARTUP.SCR. The start sequence must now be in
><  STARTUP.VCS. To create this, edit the file STARTUP.VC, then compile it
><  by typing "VCC STARTUP".

    1. This is all controlled in the file STARTUP.VCS. Looking at the file
       STARTUP.VC will show you how the music is played, and the screens are shown.
       The number after a DELAY command determine how long the screen is
       shown. This is in 'ticks'. A tick is 1/100 of a second.

    2. Make sure that any PCX images you want are 320x200x256. Unlike most
       VERGE artwork, the start-up screens and the start-up screens alone
       need not be in the correct VERGE palette, although the final screen
       shown in STARTUP.SCR should be in the correct VERGE palette so the
       New/Load/Quit menu uses the proper colors.


  C. How do I do sound effects?

    1. The master list of sound effects available for your game are listed
       in MAIN.SFX. The top number MUST equal the total number of sound
       effects in the list, and the last sound effect in the list MUST
       be NULL.WAV.

      a. Sound effects you add to this list should be, obviously, in the
         same directory and be in .WAV format, 8-bit, mono, any sampling
         rate. MAIN.SFX will automatically index them 1,2,3,etc.

      b. To use your sound effects in a game, just use the SoundEffect
         VergeC command and remember the index of the sound you wish to
         use.

      NOTE: Currently, sound effects cannot play if there is no music
            playing.

  D. How do I do music?

    1. VERGE supports any music module files for music, extensions .MOD,
       .S3M, and .XM. How to go about creating such music is beyond the
       scope of this document. However, there are plenty of these files
       created by other musicians.

       Try the Mod Archive at http://www.modarchive.com OR
       Try CDROM's collection VIA FTP at:
       ftp://ftp.cdrom.com/pub/demos/songs

       You can edit which song plays during your maps from the Map Options
       screen in MapEd (M), or when the map is created through MapEd.

  E. Ok, I've made a bunch of maps and events, and have drawn lots of cool
     characters and stuff and I have a nice little game that I want other
     people to play. How do I zip up to give it to my friends?

    1. It is general etiquette that you zip up your VERGE game demo with
       all the necessary files to run, and no others to keep the final
       .ZIP file size small and easy to download. For best results, copy
       the following files into a separate directory, then zip them up
       from there:

       MAIN.EXE
       CWSDPMI.EXE
       TRANS.TBL
       SETUP.CFG
       SETUP.DOC
       SAVEGAME.MNU
       LOADGAME.MNU
       DELGAME.MNU
       SAVELOAD.PCX
       BOX.RAW
       VERGE.PAL
       STARTUP.VCS
       PARTY.DAT
       ITEMS.DAT
       ITEMICON.DAT
       EQUIP.DAT
       MISCICON.DAT
       MAIN.SFX
       SPEECH.SPC
       MAIN.FNT
       SMALL.FNT
       EFFECTS.VCS
       NULL.WAV

       Also include your specific game files, and please only include the
       ones that are necessary for your game to run:

       .PCX files used by STARTUP.SCR
       .MAP files
       .VSP files
       .WAV files
       .CHR files
       .CR2 files
       .MOD/S3M/XM files

       And that should be it! Of course you may include some documentation
       about your game, or anything else you deem appropriate, but this is
       all you need to run the game.


GOOD LUCK and HAPPY DEVELOPING!

=============================================================================

